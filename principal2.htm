<html>
<head>

  <style>
  #superior
  { width:1064px; display:table; background-color:rgb(40,40,40); }

  #display_energia
  { margin:5 5 5 5; width:300px; height:100px; float:left;
    font-family:Courier; font-size:20pt; background-color:rgb(240,240,240);
    border-style:solid; border-width:2pt; border-color:rgb(40,40,40);
  }

  #display_pontos
  { margin:5 5 5 5; width:300px; height:100px; float:right;
    font-family:Courier; font-size:20pt; background-color:rgb(240,240,240);
    border-style:solid; border-width:2pt; border-color:rgb(40,40,40);
  }
  
  #palco
  { width:1064px; display:table; background-color:rgb(220,220,255); 
  }

  /* plano de fundo */
  #plano2
  { width:100%; height:350px;  
    background-image: url(2oplano.png);
    background-position: 0px 0px;
    animation: anim_plano2 40s linear infinite;
    -webkit-animation: anim_plano2 40s linear infinite;
    -moz-animation: anim_plano2 40s linear infinite; 
  }

  /* animação do plano de fundo */
  @keyframes anim_plano2
  {
    from  { background-position: 0 0; }
    to { background-position: 100% 0; }
  }

  @-webkit-keyframes anim_plano2
  {
    from  { background-position: 0 0; }
    to { background-position: 100% 0; }
  }

  @-moz-keyframes anim_plano2
  {
    from  { background-position: 0 0; }
    to { background-position: 100% 0; }
  }

  /* 1o plano */
  #plano1
  { width:100%; height:200px; background-color:rgb(20,255,220);}
  
  #personagem
  { position:absolute; left:50px; top:380px; width:100; height:250px; background-color:rgb(255,0,0); outline: none; }

  /* classe para animação do personagem */
  .anima_personagem
  {
    animation: anim_personagem 1000ms linear 1;
    -webkit-animation: anim_personagem 1000ms linear 1;
    -moz-animation: anim_personagem 1000ms linear 1; 
  }

  /* animação do personagem */
  @keyframes anim_personagem
  {
    0%   {background: red; top:380px;}
    50%  {background: blue; top:230px;}
    100% {background: red; top:380px;}
  }
  @-webkit-keyframes anim_personagem
  {
    0%   {background: red; top:380px;}
    50%  {background: blue; top:230px;}
    100% {background: red; top:380px;}
  }
  @-moz-keyframes anim_personagem
  {
    0%   {background: red; top:380px;}
    50%  {background: blue; top:230px;}
    100% {background: red; top:380px;}
  }

  /* obstaculo */
  #obstaculo1
  { position:absolute; left:1080px; top:580px; width:80; height:50px; background-color:white;}

  /* classe para animação do obstaculo */
  .anima_obstaculo1
  {
    animation: anim_obstaculo1 3000ms linear 1;
    -webkit-animation: anim_obstaculo1 3000ms linear 1;
    -moz-animation: anim_obstaculo1 3000ms linear 1; 
  }

  /* animação do obstaculo */
  @keyframes anim_obstaculo1
  {
    0%     {background: white; left:1080px;}
    1%     {background: blue; left:980px;}
    100%   {background: green; left:-80px;}
  }
  @-webkit-keyframes anim_obstaculo1
  {
    0%     {background: white; left:1080px;}
    1%     {background: blue; left:980px;}
    100%   {background: green; left:-80px;}
  }
  @-moz-keyframes anim_obstaculo1
  {
    0%     {background: white; left:1080px;}
    1%     {background: blue; left:980px;}
    100%   {background: green; left:-80px;}
  }

  </style>

  <script type="text/javascript">

var fase;                     // número da fase do jogo
var energia;                  // quantidade de energia (100 - máximo, 0 - mínimo -> fim de jogo)
var pontos;                   // pontuação no jogo
var nobstaculos;              // número de obstáculos que surgem em uma fase
var saltando;                 // indica se o personagem está saltando
var salto_ok;                 // indica se o personagem fez um salto OK
var saltou;                   // indica se o personagem saltou durante a passagem de um obstáculo (se não saltou houve colisão)
var conta_obstaculos;         // número de obstáculos que já passaram em uma fase
var vel_fundo;                // velocidade do fundo (em pixels/s)
var vel_1o_plano;             // velocidade do 1o plano (em pixels/s)

var ts_inicio_anim_obs;       // timestamp do início da animação do obstáculo

var WIDTH_PLANO_DE_FUNDO = 3180;  // número de pixels da largura da imagem de fundo
var WIDTH_JANELA = 1000;          // número de pixels da largura da janela

// função chamada no início (ou reinício) do jogo
function inicio()
{
  console.log("inicio()");
  
  //inicialização de variáveis 
  fase = 1;
  nobstaculos = 15;
  vel_fundo = 50;
  vel_1o_plano = 400;
  
  limpa_displays();
  seta_listeners();
  inicia_fase();
  inicia_anim_obstaculo();
}

// função para limpeza dos displays de energia e pontos
function limpa_displays()
{
  console.log("limpa_displays()");
  pontos = 0;
  energia = 100;
  atualiza_display_energia();
  atualiza_display_pontos();
}

// função para atualizar displays de energia
function atualiza_display_energia()
{
  console.log("atualiza_display_energia()");
  var el = window.document.getElementById("display_energia");
  if (!el)
    return;
  el.innerHTML = '<span>Energia: '+energia+'</span>';
}

// função para atualizar displays de pontos
function atualiza_display_pontos()
{
  console.log("atualiza_display_pontos()");
  var el = window.document.getElementById("display_pontos");
  if (!el)
    return;
  el.innerHTML = '<span>Pontos: '+pontos+'</span>';
}

// função para associar funções de tratamento para os momentos de término de animação
function seta_listeners()
{
  console.log("seta_listeners");
  
  // seta função fim_de_salto para ser chamada quando acabar o salto do personagem
  var pers_el = window.document.getElementById("personagem");
  pers_el.addEventListener("webkitAnimationEnd", fim_do_salto);
  pers_el.addEventListener("animationend", fim_do_salto);
  pers_el.focus();

  // seta função conta_iteracao para ser chamada quando acabar a passagem de um obstáculo
  var obstaculo_el = window.document.getElementById("obstaculo1");
  obstaculo_el.addEventListener("webkitAnimationEnd", final_anim_obstaculo);
  obstaculo_el.addEventListener("animationend", final_anim_obstaculo);
}

// função para iniciar uma nova fase
function inicia_fase()
{
  console.log("inicia_fase("+fase+")");

  // inicialização de flags de controle
  saltando = false;
  salto_ok = false;
  saltou = false;

  // inicialização do número de obstáculos que já passaram na fase
  conta_obstaculos = 0;
  
  // inicialização do momento de início da animação do obstáculo
  ts_inicio_anim_obs = 0;

  // recalcula tempos das animações
  calcula_tempos(); 
}

/* 
 * CALCULOS ÚTEIS PARA MUDANÇA DE FASES
 *  
 *  vel_fundo = WIDTH_PLANO_DE_FUNDO/tempo_animacao_fundo ==> tempo_animacao_fundo =  WIDTH_PLANO_DE_FUNDO / vel_plano_de_fundo;
   
   vel_1o_plano = (WIDTH_JANELA+80) / tempo_animacao_1o_plano ==> tempo_animacao_1o_plano = 1080 / vel_1o_plano;

   tempo_animacao_personagem = tempo_animacao_1o_plano / 3;

   A cada fase velocidade aumentará 50%...e se calculam os novos tempos
   */
// função chamada para recalcular os tempos das animações de fundo e de 1o plano (obstáculos)
function calcula_tempos()
{
  console.log("calcula_tempos()");

  var tempo_animacao_fundo = Math.round(WIDTH_PLANO_DE_FUNDO / vel_fundo);
  var el_plano2 = window.document.getElementById("plano2");
  el_plano2.style.WebkitAnimationDuration = tempo_animacao_fundo+"s";
  el_plano2.style.animationDuration = tempo_animacao_fundo+"s";
  console.log("Tempo plano de fundo:"+tempo_animacao_fundo);

  var tempo_animacao_1o_plano = Math.round(1000*(WIDTH_JANELA+80) / vel_1o_plano);
  var el_obs = window.document.getElementById("obstaculo1");
  el_obs.style.WebkitAnimationDuration = tempo_animacao_1o_plano+"ms";
  el_obs.style.animationDuration = tempo_animacao_1o_plano+"ms";
  console.log("Tempo 1o plano:"+tempo_animacao_1o_plano);
}

// função chamada para iniciar a animação do obstáculo
function inicia_anim_obstaculo()
{
  console.log("inicia_anim_obstaculo()");
  var obs_el = window.document.getElementById("obstaculo1");
  // associação da classe anima_obstaculo1 vai provocar o início da animação
  obs_el.className = "anima_obstaculo1";

  // armazena o timestamp (tempo) que iniciou a animação do obstáculo
  var d = new Date();
  ts_inicio_anim_obs = d.getTime();
}

// função chamada a cada finalização de animação
function final_anim_obstaculo()
{
  // incremento o número de obstáculos que já passaram
  conta_obstaculos++;
  console.log("final_anim_obstaculo() - "+conta_obstaculos);
  
  // se o personagem não teve um salto OK, então houve colisão!
  if (!saltou)
    colisao();
  saltou = false;
  
  // atualiza display de energia
  atualiza_display_energia();

  // remove animação do obstáculo (retira a classe que implementa a animação)
  var obs_el = window.document.getElementById("obstaculo1");
  obs_el.className = "";

  // verifica se houve mudança de fase
  verifica_mudanca_de_fase();

  // seta um tempo randômico entre (0,1s e 1,1s) para reiniciar animação do obstáculo
  window.setTimeout(inicia_anim_obstaculo,100+Math.floor(Math.random()*1000));
}

// função chamada quando for identificada colisão 
// (IMPORTANTE: a colisão durante o salto é detectada antes das animações se encontrarem...
//  por isso não é chamada a atualização do display de energia aqui)
function colisao()
{
  console.log("colisao()");
  perde_energia(10);
}

// função que verifica se houve mudança de fase (critério => número de obstáculos que já passaram nesta fase)
function verifica_mudanca_de_fase()
{
  console.log("verifica_mudanca_de_fase() => "+(conta_obstaculos)+" >= "+nobstaculos);
  if (conta_obstaculos >= nobstaculos)
    muda_fase();
}

// função de mudança de fase
function muda_fase()
{
  console.log("muda_fase()");
  
  // acrescenta energia como prêmio
  ganha_energia(20);
  atualiza_display_energia();
  
  // acrescenta pontos como prêmio
  acrescenta_pontos(100+50*fase);
  atualiza_display_pontos();

  // incrementa o número da fase
  fase++;
  
  // incrementa o número de obstáculos que nova fase terá
  nobstaculos += 5;

  // se a fase for < 6 aumenta a velocidade
  if (fase < 6)
  {  
    vel_fundo *= 1.5;
    vel_1o_plano *= 1.5;
  }
  
  // inicia nova fase
  inicia_fase();
}

// função de incremento de energia
function ganha_energia(incremento)
{
  console.log("ganha_energia("+incremento+")");
  energia += incremento;

  // garante que energia nunca ultrapasse 100
  if (energia > 100)
    energia = 100;
}

// função de perda de energia
function perde_energia(decremento)
{
  console.log("perde_energia("+decremento+")");
  energia -= decremento;

  // garante que energia seja menor que 0
  if (energia < 0)
    energia = 0;

  // se acabou a energia => jogo acabou
  if (energia == 0)
    finaliza_jogo();
}

// função chamada pelo acionamento de alguma tecla
function saltar()
{
  console.log("saltar()");

  // se o personagem já estiver saltando, interrompe nova execução
  if (saltando)
    return;
  
  // seta flags de controle
  saltando = true;
  
  // verifica se o salto será bem sucedido
  salto_ok = verifica_salto();
  if (salto_ok)
    saltou =  true;
  
  // insere classe que implementa a animação no personagem
  var pers_el = window.document.getElementById("personagem");
  pers_el.className = "anima_personagem";
  
  // atualiza o tempo de animação do personagem
  var tempo_animacao_personagem = Math.round(1000*(WIDTH_JANELA+80) / (3*vel_1o_plano));
  pers_el.style.WebkitAnimationDuration = tempo_animacao_personagem+"ms";
  pers_el.style.mozAnimationDuration = tempo_animacao_personagem+"ms";
  pers_el.style.animationDuration = tempo_animacao_personagem+"ms"; 
  console.log("Tempo personagem:"+tempo_animacao_personagem);
}

// função chamada para verificar se o salto foi bem sucedido
function verifica_salto()
{
  console.log("verifica_salto()");
  // se não iniciou animação não tem validade
  if (ts_inicio_anim_obs == 0)
    return false;

  // determina o intervalo de tempo decorrido (em ms) entre o tempo atual e o início da animação do obstáculo 
  var d = new Date();
  var intervalo = d.getTime()-ts_inicio_anim_obs;

  // calcula a distância do personagem até o obstáculo
  var distancia = WIDTH_JANELA-Math.round(intervalo * vel_1o_plano / 1000);
  console.log("transcorridos: "+intervalo+" ms! => distancia: "+distancia+ "pixels"); 
  
  // verifica se a distância entre o personagem e o obstáculo permite um salto OK!
  // (Obs: valores ajustados empiricamente!)
  if (distancia > 180 && distancia <= 300 )
  {    
    console.log("salto OK!"); 
    return true;
  }
  // está em uma distância em que haverá colisão
  else if (distancia > 300 && distancia <= 450) 
  {
    console.log("VAI BATER!!!");
    return false;
  }
  // se a distância muito grande é porque o salto foi feito antes da hora
  else if (distancia > 450)
  {
    console.log("salto ANTES da hora!"); 
    return false;
  }
  return false;
}

// função chamada quando ocorrer o fim da animação do personagem
function fim_do_salto()
{
  console.log("fim_do_salto()");

  // se o personagem fez um salto bem sucedido, ganha pontos
  if (salto_ok)
  {
    acrescenta_pontos(10+5*fase);
    atualiza_display_pontos();
  }

  // reseta variáveis de controle	
  saltando = false;
  salto_ok = false;

  // remove classe de animação do personagem
  var pers_el = window.document.getElementById("personagem");
  pers_el.className = "";
  
}

// função para acrescentar pontos
function acrescenta_pontos(incremento)
{ 
  console.log("acrescenta_pontos("+incremento+")");
  pontos += incremento;
}

// função para finalizar jogo
function finaliza_jogo()
{
  console.log("finaliza_jogo()");
  atualiza_display_energia();
  alert("GAME OVER");

  // após o alert, inicia um novo jogo
  inicio();
}

</script>

</head>
<body onload="inicio()">
  <div id="superior">
    <div id="display_energia">
    </div>
    <div id="display_pontos">
    </div>
  </div>
  <div id="palco">
    <div id="plano2">
    </div>
    <div id="plano1">
    </div>
    <!-- tabindex é utilizado para que o div possa receber o foco e, assim, poder tratar eventos de teclado, como onkeydown -->
    <div id="personagem" tabindex=1 onkeydown="saltar()">
    </div>
    <div id="obstaculo1">
    </div>
  </div>

</body>
</html>
